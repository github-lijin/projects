<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<title>面试题</title>
		<style type="text/css">
			body{
				font-family: "microsoft yahei";
				font-size: 16px;
			}
			h3{
				color: #000;
				text-align: center;
			}
			#container ol li{
				color: #000;
			}
			#container ol p{
				color: #666;
			}
			.image img{
				display: block;
				margin: 100px auto;
			}
		</style>
	</head>
	<body>
		<h3>高级前端开发工程师面试题汇总</h3>
		<div id="container">
			<ol>
				<li>对WEB标准以及W3C的理解与认识</li>
				<p>
					标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使
					用外 链css和js脚本、结构行为表现的分离、文件下载与页面速度
					更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、
					更少的代码和组件，容易维护、改版方便，不需要变动页面内容、
					提供打印版本而不需要复制内容、提高网站易用性；
				</p>
				<li>xhtml和html有什么区别</li>
				<p>
					HTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的置标语言
					最主要的不同：
					XHTML 元素必须被正确地嵌套。
					XHTML 元素必须被关闭。
					标签名必须用小写字母。
					XHTML 文档必须拥有根元素。
				</p>
				<li>行内元素有哪些?块级元素有哪些?CSS的盒模型?</li>
				<p>
					块级元素：div p h1 h2 h3 h4 form ul<br>
					行内元素: a b br i span input select<br>
					Css盒模型:内容，border ,margin，padding
				</p>
				<li>CSS引入的方式有哪些? link和@import的区别是?</li>
				<p>
					CSS引入的方式有内联样式、内部样式和外联样式<br>
					区别1：link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。<br>
					区别2：link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。<br>
					区别3：link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。<br>
					区别4：link支持使用Javascript控制DOM去改变样式；而@import不支持。
				</p>
				<li>CSS选择符有哪些?哪些属性可以继承?优先级算法如何计算?内联和important哪个优先级高?</li>
				<p>
					选择符有：元素选择符、关系选择符、属性选择符、伪类选择符、伪对象选择符<br>
					不可继承的：display、margin、border、padding、background、height、
					min-height、max-height、width、min-width、max-width、overflow、
					position、left、right、top、bottom、z-index、float、clear、
					table-layout、vertical-align、page-break-after、page-bread-before和unicode-bidi。<br>
					所有元素可继承：visibility和cursor<br>
					内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、
					font、font-family、font-size、font-style、font-variant、font-weight、
					text-decoration、text-transform、direction。<br>
					终端块状元素可继承：text-indent和text-align。<br>
					列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。
					优先级计算方法：内联样式（权重1000） > id（权重100） > class（权重10） > 标签（权重1），有多重选择可以相加。important优先级最高<br>
				</p>
				<li>前端页面有哪三层构成，分别是什么?作用是什么?</li>
				<p>
					结构层 html、表示层 CSS和行为层 js
				</p>
				<li>你做的页面在哪些流览器测试过?这些浏览器的内核分别是什么?</li>
				<p>
					IE(trident内核) 火狐（Gecko） 谷歌（webkit） opear(Presto,现已改用Google Chrome的Blink内核)
				</p>
				<li>写出几种IE6 BUG的解决方法</li>
				<p>
					a.双边距BUG，float引起的，使用display:inline<br>
					b.3像素问题，使用float引起的，对浮动元素使用margin-right:-3px<br>
					c.超链接hover，点击后失效，使用正确的书写顺序 link visited hover active<br>
					d.IE z-index问题，给父级添加position:relative<br>
					e.png透明，使用js代码改<br>
					f.Min-height 最小高度，使用！Important 解决<br>
					g.select 在ie6下遮盖 使用iframe嵌套<br>
					h.为什么没有办法定义1px左右的宽度容器（IE6默认的行高造成的，使用over:hidden,zoom:0.08 line-height:1px）
				</p>
				
				<li>描述css reset的作用和用途</li>
				<p>
					Reset重置浏览器的css默认属性 浏览器的品种不同，样式不同，然后重置，让他们统一
				</p>
				<li>解释css sprites，如何使用</li>
				<p>
					css精灵把一堆小的图片整合到一张大的图片上，减轻服务器对图片的请求数量，可以通过背景位置来定义不同元素的不同图片
				</p>
				<li>浏览器标准模式和怪异模式之间的区别是什么?</li>
				<p>
					盒子模型，渲染模式的不同，标准盒模型与内容相关，当内容变大时，盒子也会变大；怪异盒模型与内容无关，当内容超出盒子大小，盒子也不会变
				</p>
				<li>你如何对网站的文件和资源进行优化?</li>
				<p>
					文件合并、文件最小化/文件压缩、使用CDN托管、缓存的使用
				</p>
				<li>什么是语义化的HTML?</li>
				<p>
					直观的认识标签对于搜索引擎的抓取有好处
				</p>
				<li>清除浮动的几种方式，各自的优缺点</li>
				<p>
					a.使用空标签清除浮动 clear:both（理论上能清楚任何标签，缺点：增加无意义的标签）
					b.使用overflow:auto（空标签元素清除浮动而不得不增加无意代码的弊端,,使用zoom:1用于兼容IE）
					c.是用afert伪元素清除浮动(用于非IE浏览器)
				</p>
				<li>HTML5 有哪些新增的表单元素？</li>
				<p>
					datalist、datetime、output、keygen、date 、month 、week、time、color、number 、range 、email 、url
				</p>
				<li>HTML5 废弃了哪些 HTML4 标签？</li>
				<p>
					frame、noframe、frameset、applet、big、center、basefront
				</p>
				<li>HTML5 标准提供了哪些新的 API？</li>
				<p>
					Media API<br>
					Text Track API<br>
					Application Cache API<br>
					User Interaction<br>
					Data Transfer API<br>
					Command API<br>
					Constraint Validation API<br>
					History API
				</p>
				<li>Quirks模式是什么？它和Standards模式有什么区别</li>
				<p>
					从IE6开始，引入了Standards模式，标准模式中，浏览器尝试给符合标准的文档在规范上的正确处理达到在指定浏览器中的程度。<br>
					
				</p>
				<li>div+css的布局较table布局有什么优点？</li>
				<p>
					改版的时候更方便 只要改css文件。<br>
					页面加载速度更快、结构化清晰、页面显示简洁。<br>
					表现与结构相分离。<br>
					易于优化（seo）搜索引擎更友好，排名更容易靠前。
				</p>
				<li>请描述一下cookies，sessionStorage和localStorage的区别？</li>
				<p>
					sessionStorage用于本地存储一个会话（session）中的数据，这些
					数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随
					之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会
					话级别的存储。而localStorage用于持久化的本地存储，除非主动
					删除数据，否则数据是永远不会过期的<br>
					Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次
					你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费
					了带宽，另外cookie还需要指定作用域，不可以跨域调用<br>
					•除此之外，Web Storage拥有setItem,getItem,removeItem,clear等
					方法，不像cookie需要前端开发者自己封装setCookie，getCookie。但
					是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范
					的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生
				</p>
				<li>简述一下src与href的区别。</li>
				<p>
					src用于替换当前元素，href用于在当前文档和引用资源之间确立联系
				</p>
				<li>知道什么是微格式吗？谈谈理解。在前端构建中应该考虑微格式吗？</li>
				<p>
					微格式（Microformats）是一种让机器可读的语义化XHTML词汇的集合，
					是结构化数据的开放标准。是为特殊应用而制定的特殊格式。
				</p>
				<li>在css/js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理？</li>
				<p>
					dns缓存，cdn缓存，浏览器缓存，服务器缓存
				</p>
				<li>一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验</li>
				<p>
					•图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断
					图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。<br>
					•如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。<br>
					•如果图片为css图片，可以使用CSSsprite，SVGsprite，Iconfont、Base64等技术。<br>
					•如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。<br>
					•如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。
				</p>
				
				<li>谈谈以前端角度出发做好SEO需要考虑什么？</li>
				<p>
					•了解搜索引擎如何抓取网页和如何索引网页<br>
					•Meta标签优化<br>
					•如何选取关键词并在网页中放置关键词<br>
					•了解主要的搜索引擎<br>
					•主要的互联网目录<br>
					•按点击付费的搜索引擎<br>
					•搜索引擎登录<br>
					•合理的标签使用<br>
					•链接交换和链接广泛度（Link Popularity）
				</p>
				<li>超链接访问过后hover样式就不出现的问题是什么？如何解决？</li>
				<p>
					被点击访问过的超链接样式不在具有hover和active了,解决方法是改变CSS属性的排列顺序: L-V-H-A（link,visited,hover,active）
				</p>
				<li>css中可以让文字在垂直和水平方向上重叠的两个属性是什么？</li>
				<p>
					垂直方向：line-height、水平方向：letter-spacing
				</p>
				<li>px和em的区别</li>
				<p>
					px和em都是长度单位，区别是，px的值是固定的，指定是多少就是多少，计算比较
					容易。em得值不是固定的，并且em会继承父级元素的字体大小
				</p>
				<li>Sass、LESS是什么？大家为什么要使用他们？</li>
				<p>
					他们是CSS预处理器。他是CSS上的一种抽象层。他们是一种特殊的语法/语言编译成CSS。<br>
					•结构清晰，便于扩展。<br>
					•可以方便地屏蔽浏览器私有语法差异。这个不用多说，封装对浏览器语法差异的重复处理，减少无意义的机械劳动。<br>
					•可以轻松实现多重继承。<br>
					•完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。
				</p>
				<li>websocket</li>
				<p>
					websocket是一种协议，可以让我们建立客户端到服务器端的全双工通信，这就意味着服务器端可以主动推送数据到客户端，
				</p>
				<li>web worker</li>
				<p>
					web worker是运行在浏览器后台的js程序，他不影响主程序的运行，是另开的一个js线程，可以用这个线程执行复杂的数据操作，然后把操作结果通过postMessage传递给主线程，这样在进行复杂且耗时的操作时就不会阻塞主线程了。
				</p>
				<li>重构、回流</li>
				<p>
					·浏览器的重构指的是改变每个元素外观时所触发的浏览器行为，比如颜色，背景等样式发生了改变而进行的重新构造新外观的过程。重构不会引发页面的重新布局，不一定伴随着回流，<br/>
					·回流指的是浏览器为了重新渲染页面的需要而进行的重新计算元素的几何大小和位置的，他的开销是非常大的，回流可以理解为渲染树需要重新进行计算，一般最好触发元素的重构，避免元素的回流；比如通过通过添加类来添加css样式，而不是直接在DOM上设置，当需要操作某一块元素时候，最好使其脱离文档流，这样就不会引起回流了，比如设置position：absolute或者fixed，或者display：none，等操作结束后在显示。
				</p>
				<li>JavaScript的闭包</li>
				<p>
					闭包简单的说就是一个函数能访问外部函数的变量，这就是闭包
				</p>
				<li>JavaScript的继承</li>
				<p>
					原型继承、构造函数继承、原型继承+构造函数继承
				</p>
				<li>http状态码</li>
				<p>
					100（continue），客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收<br/>
					200（OK），表示请求成功，请求所希望的响应头或数据体将随此响应返回。<br/>
					202（Accepted），服务器已接受请求，但尚未处理。<br/>
					204（No-Content），服务器成功处理了请求，但不需要返回任何实体内容<br/>
					205（Reset-Content），服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。<br/>
					206（Partial-Content），服务器已经成功处理了部分 GET 请求。<br/>
					301（Moved-Permanently），永久性重定向<br/>
					302（Moved-Temporarily），暂时性重定向<br/>
					304（Not-Modified），浏览器端缓存的资源依然有效400（Bad-Reques），请求有误，当前请求无法被服务器理解。<br/>
					401（Unauthorized），当前请求需要用户验证。<br/>
					403（Forbidden），服务器已经理解请求，但是拒绝执行它。<br/>
					404（Not-Found），请求的资源没有被找到<br/>
					500（Interval Server Error），服务器内部错误<br/>
					502（Bad GateWay），网关出错<br/>
					503（Service Unavailable），由于临时的服务器维护或者过载，服务器当前无法处理请求。<br/>
					504（Gateway Timeout），作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。
				</p>
				<li>xss，csrf的概念以及防范方法</li>
				<p>
					XSS攻击类似于SQL注入攻击，攻击之前，我们先找到一个存在XSS漏洞的网站，XSS漏洞分为两种，一种是DOM Based XSS漏洞，另一种是Stored XSS漏洞。理论上，所有可输入的地方没有对输入数据进行处理的话，都会存在XSS漏洞，漏洞的危害取决于攻击代码的威力，攻击代码也不局限于script<br>
					CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。<br>
				</p>
				<li>CommonJs，AMD，CMD规范</li>
				<p>
					AMD 即Asynchronous Module Definition，中文名是异步模块定义的意思。它是一个在浏览器端模块化开发的规范<br>
					CMD 即Common Module Definition通用模块定义，CMD规范是国内发展出来的，就像AMD有个requireJS，CMD有个浏览器的实现SeaJS，SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同
				</p>
				<li>谈谈对前端模块化的理解</li>
				<p>
					前端模块话就是把复杂的文件分成一个个独立的模块，比如js文件，分成独立的模块之后有利于代码的重用和维护，但是这样又会引来模块与模块之间的依赖问题，所以就有了CommonJS、AMD、CMD规范
				</p>
				<li>如何解决跨域问题</li>
				<p>
					JSONP：
		
					原理是：动态插入 script 标签，通过 script 标签引入一个 js 文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的 json 数据作为参数传入。
					CORS
		
						服务器端对于 CORS 的支持，主要就是通过设置 Access-Control-Allow-Origin 来进行的。如果浏览器检测到相应的设置，就可以允许 Ajax 进行跨域的访问。
				</p>
				<li>谈谈你对webpack的看法</li>
				<p>
					WebPack 是一个模块打包工具，你可以使用 WebPack 管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包Web开发中所用到的 HTML、JavaScript、CSS 以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源， webpack 有对应的模块加载器。 webpack 模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源。
				</p>
				<li>说说TCP传输的三次握手四次挥手策略</li>
				<p>
					为了准确无误地把数据送达目标处， TCP 协议采用了三次握手策略。用TCP协议把数据包送出去后， TCP 不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志： SYN 和 ACK 。
		
					发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。 最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。 若在握手过程中某个阶段莫名中断， TCP 协议会再次以相同的顺序发送相同的数据包。
				</p>
				<li>HTTP和HTTPS</li>
				<p>
					HTTP 协议通常承载于TCP协议之上，在 HTTP 和 TCP 之间添加一个安全协议层（ SSL 或 TSL ），这个时候，就成了我们常说的HTTPS。
		
					默认HTTP的端口号为80， HTTPS 的端口号为443。
				</p>
				<li>ES6的了解</li>
				<p>
					新增模板字符串（为JavaScript提供了简单的字符串插值功能）、箭头函数（操作符左边为输入的参数，而右边则是进行的操作以及返回的值 Inputs=>outputs 。）、for-of （用来遍历数据—例如数组中的值。） arguments 对象可被不定参数和默认参数完美代替。 ES6 将 promise 对象纳入规范，提供了原生的 Promise 对象。增加了 let 和 const 命令，用来声明变量。增加了块级作用域。let命令实际上就增加了块级作用域。ES6规定， var 命令和 function 命令声明的全局变量，属于全局对象的属性； let 命令、 const 命令、 class 命令声明的全局变量，不属于全局对象的属性。。还有就是引入 module 模块的概念
				</p>
				<li>关于Http 2.0 你知道多少？</li>
				<p>
					HTTP/2 引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。
		
					HTTP/2 提供更多的加密支持
		
					HTTP/2 使用多路技术，允许多个消息在一个连接上同时交差。
		
					它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的 header 都只会占用很小比例的带宽。
				</p>
				<li>defer和async</li>
				<p>
					defer并行加载js文件，会按照页面上script标签的顺序执行 async并行加载js文件，下载完成立即执行，不会按照页面上script标签的顺序执行
				</p>
				<li>如何评价AngularJS和BackboneJS</li>
				<p>
					backbone 具有依赖性，依赖 underscore.js 。 Backbone + Underscore + jQuery(or Zepto) 就比一个 AngularJS 多出了2 次HTTP请求.
		
					Backbone 的 Model 没有与UI视图数据绑定，而是需要在View中自行操作DOM来更新或读取UI数据。 angularjs 与此相反，Model直接与UI视图绑定， Model 与UI视图的关系，通过 directive 封装， AngularJS 内置的通用 directive ，就能实现大部分操作了，也就是说，基本不必关心 Model 与UI视图的关系，直接操作Model就行了，UI视图自动更新。
		
					AngularJS 的 directive ，你输入特定数据，他就能输出相应UI视图。是一个比较完善的前端MVW框架，包含模板，数据双向绑定，路由，模块化，服务，依赖注入等所有功能，模板功能强大丰富，并且是声明式的，自带了丰富的 Angular 指令。
				</p>
				<li>用过哪些设计模式？</li>
				<p>
					工厂模式：
					主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字。将所有实例化的代码集中在一个位置防止代码重复。
		
		   			 工厂模式解决了重复实例化的问题 ，但还有一个问题,那就是识别问题，因为根本无法 搞清楚他们到底是哪个对象的实例。
		   			 构造函数模式:
		   			 使用构造函数的方法 ，即解决了重复实例化的问题 ，又解决了对象识别的问题，该模式与工厂模式的不同之处在于：
				</p>
				<li>call() 和 apply() 的区别和作用？</li>
				<p>
					作用：动态改变某个类的某个方法的运行环境（执行上下文）。
				</p>
				<li>WEB应用从服务器主动推送Data到客户端有那些方式？</li>
				<p>
					Javascript数据推送
		
						Commet ：基于HTTP长连接的服务器推送技术
		
						基于 WebSocket 的推送方案
		
						SSE （Server-Send Event）：服务器推送数据新方式
				</p>
				<li>说说你对Promise的理解</li>
				<p>
					依照 Promise/A+ 的定义， Promise 有四种状态：
		
					pending: 初始状态, 非 fulfilled 或 rejected.
		
					fulfilled: 成功的操作.
		
					rejected: 失败的操作.
		
					settled: Promise已被fulfilled或rejected，且不是pending
		
					另外， fulfilled 与 rejected 一起合称 settled 。
		
					Promise 对象用来进行延迟(deferred) 和异步(asynchronous ) 计算。
				</p>
				<li>说说严格模式的限制</li>
				<p>
					变量必须声明后再使用
		
					函数的参数不能有同名属性，否则报错
		
					不能使用with语句
		
					不能对只读属性赋值，否则报错
		
					不能使用前缀0表示八进制数，否则报错
		
					不能删除不可删除的属性，否则报错
		
					不能删除变量delete prop，会报错，只能删除属性delete global[prop]
		
					eval不会在它的外层作用域引入变量
		
					eval和arguments不能被重新赋值
		
					arguments不会自动反映函数参数的变化
		
					不能使用arguments.callee
		
					不能使用arguments.caller
		
					禁止this指向全局对象
		
					不能使用fn.caller和fn.arguments获取函数调用的堆栈
		
					增加了保留字（比如protected、static和interface）
				</p>
				<li>说说你对MVC和MVVM的理解</li>
				<p>
				    MVC
					View 传送指令到 Controller
		
					Controller 完成业务逻辑后，要求 Model 改变状态
		
					Model 将新的数据发送到 View，用户得到反馈
					<br>
				    MVVM
		
					组成部分Model、View、ViewModel
		
					View：UI界面
		
					ViewModel：它是View的抽象，负责View与Model之间信息转换，将View的Command传送到Model；
		
					Model：数据访问层
				</p>
			</ol>
			<div class="image">
				<img src="img/Front_End_Engineer_Knowledge.jpg" alt="思维脑图" title="思维脑图"/>
				<img src="img/u=1723562329,995948630&fm=214&gp=0.jpg" alt="思维脑图" title="思维脑图"/>
			</div>
		</div>
	</body>
</html>
